---
layout: post
title: Python 3, Bottle.py, Apache and WSGI - Import Nightmares
date: 2015-09-23 23:19:01

mast: mandel
---

At some point in a webdev's life, one might consider moving away from classic web
development in for example PHP, and move on to more convenient frameworks. If
you already know a language, learning another one just for web development can
also seem like a waste of time. Alternatives might be more elegant, flexible,
and better integrated with the things you're currently writing. I found myself
in the position of having to demo my work on
[author profiling](https://www.uni-weimar.de/medien/webis/events/pan-15/pan15-web/author-profiling.html)
that was completely written in Python 3 (`shed` + `sklearn`). The problem with
framework switching, I found, is learning how to do frustratingly arbitrary
operations all over again. Moreover, however sluggish
[LAMP](https://en.wikipedia.org/wiki/LAMP_%28software_bundle%29) set-ups might
seem, they are very robust, well-understood and have plenty of documentation.
Changing to more obscure environments like I did with `bottle.py` can shovel you
in the face at any point. It's been a bumpy road to say the least, so to help
any pursuers of this path in the future, I hereby present you with my findings
thus far.

## Bottle.py

[Bottle.py](http://bottlepy.org/docs/dev/index.html) is a very minimalistic web-
framework for Python. It is so small that delivering `hello world` to a port is
literally this:

```python
from bottle import route, run

@route('/')
def index():
    return "hello world"

run(host='localhost', port=8080)
```

It works with all your existing code and libraries that Python has. So say that
you want to test an already trained SVM classifier with
[bigram](http://scikit-learn.org/stable/modules/feature_extraction.html#common-vectorizer-usage)
features on data fed by a query it can be as much as:

``` python
# file: whatever.py
from bottle import route, run
import sklearn
import pickle

clf = pickle.load(open('/somedir/model.pickle', 'rb'))
big = pickle.load(open('/somedir/bigram_vectorizer.pickLe', 'rb'))

@route('/<query>')
def index(query):
    v = big.transform([query]).toarray()
    return clf.predict(v)[0]

run(host='localhost', port=8080)
```

That's right, no POST, no GET, you can directly feed a string to `localhost` if
you desire. And with these few lines of code I was completely blown away by the
elegance of the framework. Everyting is all well and good, until you actually
want to implement your app in an existing web server environment. Chances are
huge that this will be in Apache. Traditional protocols for Apache do not handle
these kind of apps, though, and so WSGI was brought to life.

## Apache & WSGI

Without filling this post with the [specifics](http://www.fullstackpython.com/wsgi-servers.html)
and motivations behind WSGI, let's immediately jump into how to configure
Bottle.py and Apache to run this stuff. First we need to do a bit of work in
our `whatever.py` that had the bottle code. After renaming it to `app.wsgi` it
should contain the following:

{% highlight python %}
import os, sys
import bottle
from beaker.middleware import SessionMiddleware

os.chdir(os.path.dirname(__file__))
sys.path.append(os.path.dirname(__file__))

application = SessionMiddleware(bottle.app())

clf = pickle.load(open('/somedir/model.pickle', 'rb'))
big = pickle.load(open('/somedir/bigram_vectorizer.pickLe', 'rb'))

@bottle.route('/<query>')
def index(query):
    v = big.transform([query]).toarray()
    return clf.predict(v)[0]
{% endhighlight %}

So obviously we are not serving to a port anymore. Apache will pick up the
app and serve it to wherever you wish. The `path` part is important as the
directory orientation changes when everything is loaded into Apache, so your
new app still needs to know where all the files are at. Now that our file is
done, we need to configure Apache to fetch it. In Linux, this is done as
follows:

{% highlight %}
cd /etc/apache2/sites-available
nano yourappname.conf
{% endhighlight %}
