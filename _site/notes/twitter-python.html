<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>The Twitter API and Python - Syntactic Sugar for Tweepy</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@_cmry" /><meta name="twitter:title" content="The Twitter API and Python - Syntactic Sugar for Tweepy" /><meta name="twitter:description" content="Lately I have been collecting a large amount of tweets for building a good representation of Twitter-user’s expected social discourse and its meta-data. Basically, a fancy way of saying that I want..."><meta name="description" content="Lately I have been collecting a large amount of tweets for building a good representation of Twitter-user’s expected social discourse and its meta-data. Basi..."><link rel="stylesheet" type="text/css" href="/assets/light.css" /><link rel="alternate stylesheet" type="text/css" href="/assets/dark.css" title="dark" /><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"> <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [["$","$"], ['\\(','\\)']]}});</script> <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> <script type="text/javascript" src="/assets/styleswitcher.js"></script><link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro' rel='stylesheet' type='text/css'><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="canonical" href="/notes/twitter-python"><link rel="alternate" type="application/atom+xml" title="Chris Emmery" href="/feed.xml" /></head><body><aside class="logo"><nav><div class="links"> <a href="/"><i class="fa fa-home"></i></a> » <a id="ind-publ" href="/publ">publ</a> » <a id="ind-code" href="/code">code</a> » <a id="ind-work" href="/work">work</a> » <a id="ind-about" href="/about">about</a> » <a id="ind-contact" href="/contact">contact</a> » <a href="#" onclick="setActiveStyleSheet('dark'); return false;"><i class="fa fa-ge" aria-hidden="true"></i></a> <a href="#" onclick="setActiveStyleSheet('light'); return false;"><i class="fa fa-ra" aria-hidden="true"></i></a></div></nav></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><h1>The Twitter API and Python - Syntactic Sugar for Tweepy</h1><time>May 8, 2015 | 12 minute read </time><div class="divider"></div><p>Lately I have been collecting a large amount of tweets for building a good representation of Twitter-user’s expected social discourse and its meta-data. Basically, a fancy way of saying that I want to see who <em>publicly</em> shares what, and with whom. After some digging around, I settled for <a href="https://tweepy.readthedocs.org/">Tweepy</a> to interface with the Twitter API. There were several scenarios which I was looking to implement: grab the available associates (followers, friends) and public timeline given a user’s name, and resolving a large number of tweets given a set of tweet IDs. Don’t get me wrong, Tweepy offers a very nice interface. It was a bit too general-purpose for my liking though, so I started building a wrapper class around Tweepy. In this post, I will talk a bit about its functionality, considerations and future improvements while discussing the task of utilizing the Twitter API for Natural Language Processing-related research.</p><p><img src="http://www.dototot.com/wp-content/uploads/2013/11/guidoTwitterBot_final1-1.jpg" alt="twitter" /></p><h2 id="introduction">Introduction</h2><p>Twitter’s short messaging system has been a well known hurdle for many tasks related to Natural Language Processing (NLP). Most of the techniques in its field tend to work very well given enough context per document; something which is clearly constrained in tweets. It therefore makes for a very challenging and equally interesting platform to work with. Accessing its data, however, can prove a time consuming task. To illustrate: if you’re interested in a specific topic relevant for only a region or language (such as political tweets), you can either hope to get some share of this in its <a href="https://dev.twitter.com/streaming/overview">stream</a>, or constrain it with geo location (which many people do not enable). Keeping in mind that a <a href="https://www.quora.com/How-much-does-access-to-the-Twitter-firehose-cost?share=1">normal human being</a> only has access to a very small percentage of this stream makes it all the more annoying at times. One might think: well, if I know a person who’s from the country I’m interested in, I can just pull his tweets and look at those of his friends as well, right? Turns out it’s not that simple.</p><h2 id="the-twitter-api--tweepy">The Twitter API &amp; Tweepy</h2><p>Twitter offers an interface to the tasks I described above, as well as a wide variety of most other information one would like to get his hands on. These can in essence be accessed through a <a href="#">REST</a> interface, which might be rather unintuitive to novel users. Luckily most programming languages offer a wrapper for this API, <a href="https://tweepy.readthedocs.org/">Tweepy</a> for Python being one of them. To access the API, you need a Twitter account and developer credentials - the latter of which can be obtained by creating an ‘app’, for which one can refer to <a href="https://apps.twitter.com/">apps section</a>. After receiving your brand spanking new app environment, it will list a <em>manage keys and access tokens</em> point near the Consumer Key. From that section, you can generate the tokens needed to fill in for authorization, which I will refer to as <code class="highlighter-rouge">cons_key</code>, <code class="highlighter-rouge">cons_sec</code>, <code class="highlighter-rouge">accs_tok</code>, <code class="highlighter-rouge">accs_sec</code>. There are two steps to this authorization; app-level authorization, and-user level authorization. The <code class="highlighter-rouge">cons_</code> keys are needed for app-level, and need to be combined with the <code class="highlighter-rouge">accs_</code> ones for user-level authorization. This will give us app-level:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">tweepy</span>

<span class="n">cons_key</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXXXXXX'</span> <span class="c"># own key</span>
<span class="n">cons_sec</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXXXXXX'</span> <span class="c"># own key</span>

<span class="n">auth</span> <span class="o">=</span> <span class="n">tweepy</span><span class="o">.</span><span class="n">AppAuthHandler</span><span class="p">(</span><span class="n">cons_key</span><span class="p">,</span> <span class="n">cons_sec</span><span class="p">)</span>
</code></pre></div><p>While this is needed for user-level:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">cons_key</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXXXXXX'</span> <span class="c"># own key</span>
<span class="n">cons_sec</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXXXXXX'</span> <span class="c"># own key</span>
<span class="n">accs_tok</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXX'</span> <span class="c"># own key</span>
<span class="n">accs_sec</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXX'</span> <span class="c"># own key</span>

<span class="n">auth</span> <span class="o">=</span> <span class="n">tweepy</span><span class="o">.</span><span class="n">OAuthHandler</span><span class="p">(</span><span class="n">cons_key</span><span class="p">,</span> <span class="n">cons_sec</span><span class="p">)</span>
<span class="n">auth</span><span class="o">.</span><span class="n">set_access_token</span><span class="p">(</span><span class="n">accs_tok</span><span class="p">,</span> <span class="n">accs_sec</span><span class="p">)</span>
</code></pre></div><p>Notice that the latter has a different Handler, and needs to add the tokens after creating the <code class="highlighter-rouge">auth</code> variable. If no errors are thrown, you are good to go! Given that we authenticated ourselves, we can now move the <code class="highlighter-rouge">auth</code> variable in the API, and do something such as:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">api</span> <span class="o">=</span> <span class="n">tweepy</span><span class="o">.</span><span class="n">API</span><span class="p">(</span><span class="n">auth</span><span class="p">)</span>
<span class="n">api</span><span class="o">.</span><span class="n">friends</span><span class="p">(</span><span class="s">'username'</span><span class="p">)</span>
</code></pre></div><p>Which will return up until some amount of friend-names in a list! Great! Now that wasn’t so hard, right? Not yet.</p><h2 id="twitter-rate-limits--pagination">Twitter Rate Limits &amp; Pagination</h2><p>Well, turns out Twitter has long monetized its data access, and therefore only allows you to pull this <code class="highlighter-rouge">api.friends</code> for different accounts only some X amount of times per 15 minutes. These rate limits vary per access level (user/app), which is acceptably well documented <a href="https://dev.twitter.com/rest/public/rate-limiting">here</a> (Twitter docs can be incredibly vague). On top of that, the amount of entries that can be retrieved per ‘page’ also varies. Example: say that we want to list all the friends from some guy or girl who has more than 200 friends. Twitter only allows us to access these in pages of 200 friends. So in the previous example where I just called <code class="highlighter-rouge">api.friends('username')</code> we would get 200 friends only, even if the person has more. To solve this, we need to use a <code class="highlighter-rouge">Cursor</code> function, which in Python is similar to a <a href="">generator</a>. You can call its <code class="highlighter-rouge">pages()</code> for iteration, which works as follows:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">cursor</span> <span class="o">=</span> <span class="n">tweepy</span><span class="o">.</span><span class="n">Cursor</span><span class="p">(</span><span class="n">api</span><span class="o">.</span><span class="n">friends</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="k">for</span> <span class="n">page</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">pages</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">friend</span> <span class="ow">in</span> <span class="n">page</span><span class="p">:</span>
        <span class="c"># do something with a friend</span>
</code></pre></div><p>Each time we access the API, regardless of doing this in <code class="highlighter-rouge">cursor.pages()</code> or without, Twitter will count it as one access instance. Per access instance, Twitter substracts one from the rate limit counter. These rate limits can be viewed with <code class="highlighter-rouge">api.rate_limit_status()</code>, which returns a dict listing, amongst others, remaining queries per function. So if we look this up for the query we previously used, we see:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">In</span> <span class="p">[</span><span class="mi">4</span><span class="p">]:</span> <span class="n">api</span><span class="o">.</span><span class="n">rate_limit_status</span><span class="p">()[</span><span class="s">'resources'</span><span class="p">][</span><span class="s">'friends'</span><span class="p">]</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
<span class="p">{</span><span class="s">'/friends/following/ids'</span><span class="p">:</span> <span class="p">{</span><span class="s">'limit'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s">'remaining'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="o">...</span><span class="p">},</span>
 <span class="s">'/friends/following/list'</span><span class="p">:</span> <span class="p">{</span><span class="s">'limit'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
  <span class="s">'remaining'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span>
  <span class="s">'reset'</span><span class="p">:</span> <span class="mi">1430993361</span><span class="p">},</span>
 <span class="s">'/friends/ids'</span><span class="p">:</span> <span class="p">{</span><span class="s">'limit'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s">'remaining'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s">'reset'</span><span class="p">:</span> <span class="mi">1430993361</span><span class="p">},</span>
 <span class="s">'/friends/list'</span><span class="p">:</span> <span class="p">{</span><span class="s">'limit'</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="s">'remaining'</span><span class="p">:</span> <span class="mi">29</span><span class="p">,</span> <span class="s">'reset'</span><span class="p">:</span> <span class="mi">1430993361</span><span class="p">}}</span>
</code></pre></div><p>Note that at ‘/friends/list’ we can only query 30 times as an authenticated app, and we queried once, so we have 29 remaining. These rate limits reset once every 15 minutes - the ‘reset’ counter keeps track of how much time remains until this renews (in <a href="https://en.wikipedia.org/wiki/Unix_time"><del>Epoch</del> Unix time</a>). Therefore, the optimal interval $i = 15 \cdot 60 / lim$, where $lim$ is the limit. With this, we can define the time it will take to process a query ($t(q)$), by incorporating the number of results $max$ we can get per <code class="highlighter-rouge">Cursor</code>, and the total instances $sum$. As such:</p><p>\begin{equation} t(q) = \frac{sum}{max} \cdot i = \frac{sum}{max} \cdot \frac{15 \cdot 60}{lim} \end{equation}</p><p>So say that we have three profiles with 1000 ($max = 1000 \cdot 3$) friends, this would result in $t(q) = 3000 / 200 \cdot 15\cdot60 / 30 = 450$ seconds (!) for three profiles. This isn’t such a big deal when we’re only interested in a fairly small amount of people. Otherwise we’ll have to sit this query process out for a while, which definitely needs to be taken into account whilst designing an experimental setup.</p><p>When writing a program that uses this API and which has to deal with its rate limits, it would be a good thing to optimize the amount of queries per some amount of seconds, especially when database interactions, preprocessing and this kind of stuff is happening in the background and taking up time before the next query. This was one of the reasons I started developing the wrapper for Tweepy; to make sure that the $t(q)$ in our equation is very approximate to the amount of time the class methods will be taking.</p><h3 id="syntactic-sugar">Syntactic Sugar</h3><p>As you might know, syntactic sugar is a way to describe syntax in a programming language that makes it ‘tastier to consume’: easier to read, work with, or just to make things work in an alternative style. Now while this is predominantly used for lower-level code, it also works well to describe a type of wrapper. The aim is then to simplify certain interactions, that do mostly the same as existing code, but in a more intuitive or task-specific manner (of which the latter is the case here). So, let’s get into the design now.</p><h2 id="class-__init__">Class <code class="highlighter-rouge">__init__</code></h2><p>We start off initiating the class, of course, and setting some of the first local parameters. Please note that I will truncate the docstrings and only leave the parameters, the code is documented on <a href="">github</a>. Moving the <code class="highlighter-rouge">auth</code> function to be called by either ‘user’ or ‘app’ makes fiddling with the different handler classes a little less troublesome. Now starting for example <code class="highlighter-rouge">api = TwAPI('user')</code> already gives a fully authenticated api object to work with directly!</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">tweepy</span> <span class="kn">as</span> <span class="nn">twp</span>

<span class="k">class</span> <span class="nc">TwAPI</span><span class="p">:</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="s">"""
        :mode: either "user" or "app"
        :return: nothing
        """</span>

        <span class="n">cons_key</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXXXXXX'</span> <span class="c"># own key</span>
        <span class="n">cons_sec</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXXXXXX'</span> <span class="c"># own key</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">"user"</span><span class="p">:</span>
            <span class="n">accs_tok</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXX'</span> <span class="c"># own key</span>
            <span class="n">accs_sec</span> <span class="o">=</span> <span class="s">'XXXXXXXXXXXXX'</span> <span class="c"># own key</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">auth</span> <span class="o">=</span> <span class="n">twp</span><span class="o">.</span><span class="n">OAuthHandler</span><span class="p">(</span><span class="n">cons_key</span><span class="p">,</span> <span class="n">cons_sec</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">auth</span><span class="o">.</span><span class="n">set_access_token</span><span class="p">(</span><span class="n">accs_tok</span><span class="p">,</span> <span class="n">accs_sec</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s">"app"</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">auth</span> <span class="o">=</span> <span class="n">twp</span><span class="o">.</span><span class="n">AppAuthHandler</span><span class="p">(</span><span class="n">cons_key</span><span class="p">,</span> <span class="n">cons_sec</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">api</span> <span class="o">=</span> <span class="n">twp</span><span class="o">.</span><span class="n">API</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auth</span><span class="p">)</span>
</code></pre></div><blockquote><p><strong>Note:</strong> For future work, it is probably a good idea to move the tokens a bit higher level in the code (like in a dict) so you don’t have to fiddle inside the class. Might also be better to make TwAPI an api class, so you can just call <code class="highlighter-rouge">self.user_timeline</code> instead of <code class="highlighter-rouge">self.api.user_timeline</code>.</p></blockquote><h2 id="profile-based-methods">Profile-based methods</h2><p>Adding pieces of code to just retrieve friends and timelines isn’t that big of a deal, as we saw before. We integrate the cursor part and the iterator in separate methods and we just call the appropriate Tweepy function:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_friends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">twp</span><span class="o">.</span><span class="n">Cursor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">friends</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">pages</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">screen_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span>

<span class="k">def</span> <span class="nf">get_timeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">twp</span><span class="o">.</span><span class="n">Cursor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">user_timeline</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">tweet</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tweet</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span>
</code></pre></div><p>Both of these functions have a preset maximum count window, and store all the retrieved data in one list, and return that. Due to memory constrains on big sets, it could be better to do it in a generator. For this, we edit this bit:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="o">-</span> <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">pages</span><span class="p">():</span>
      <span class="k">for</span> <span class="n">user</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
<span class="o">+</span>         <span class="k">yield</span> <span class="n">user</span><span class="o">.</span><span class="n">screen_name</span>
<span class="o">-</span>         <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">user</span><span class="o">.</span><span class="n">screen_name</span><span class="p">)</span>
<span class="o">-</span> <span class="k">return</span> <span class="n">l</span>
</code></pre></div><p>Then we interact with these class methods like so:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="n">In</span> <span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="n">api</span> <span class="o">=</span> <span class="n">TwAPI</span><span class="p">(</span><span class="s">'user'</span><span class="p">)</span>

<span class="n">In</span> <span class="p">[</span><span class="mi">2</span><span class="p">]:</span> <span class="n">api</span><span class="o">.</span><span class="n">get_friends</span><span class="p">(</span><span class="s">'_cmry'</span><span class="p">)</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
<span class="p">[</span><span class="s">'ProjectJupyter'</span><span class="p">,</span>
<span class="o">...</span><span class="p">]</span>
</code></pre></div><p>Note that this assumes that you want pagination anyway; there is no real reason to call the method without a cursor. In normal code, it is just a tad neater to omit this if you do not need multiple pages. This implies, however, that it will <strong>always</strong> retrieve the entire object. If you decide that someone with 1000 friends has only a relevant slice of the first or last 200, then it’s best to alter the code. Moreover, though the methods have very similar functionality, their ‘pre-sets’ (<code class="highlighter-rouge">count</code>, field calls) make it so that abstraction was avoided on purpose.</p><h2 id="handling-rate-limits">Handling Rate Limits</h2><p>Either way, these functions do not have real added value as-is, and we will quickly run into the <a href="https://dev.twitter.com/rest/public/rate-limits">API rate limits</a> as we have them set up now. That’s why I implemented a waiting function to correct for both processing time and amount of queries allowed per 15 minutes. The current version looks a bit horrible, but the general idea is as follows:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span><span class="p">,</span> <span class="n">strftime</span><span class="p">,</span> <span class="n">time</span>

<span class="n">TIME</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

<span class="o">...</span>

<span class="k">def</span> <span class="nf">sleepy_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">):</span>
    <span class="s">"""
    TODO: make the limit fetch itself given a target so we can get
          rid of the ugly if/elif statements that do the same. Can
          be fetched from self.api.rate_limit_status()['resources'].

    :sw: friends or messages
    :return: float cooldown seconds
    """</span>
    <span class="k">global</span> <span class="n">TIME</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">strftime</span><span class="p">(</span><span class="s">'</span><span class="si">%</span><span class="s">H:</span><span class="si">%</span><span class="s">M:</span><span class="si">%</span><span class="s">S'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sw</span> <span class="o">==</span> <span class="s">'friends'</span><span class="p">:</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># correct</span>
    <span class="k">elif</span> <span class="n">sw</span> <span class="o">==</span> <span class="s">'messages'</span><span class="p">:</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="mi">180</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s">"user"</span> <span class="k">else</span> <span class="mi">60</span>
    <span class="k">elif</span> <span class="n">sw</span> <span class="o">==</span> <span class="s">'timeline'</span><span class="p">:</span>
        <span class="n">lim</span> <span class="o">=</span> <span class="mi">180</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s">"user"</span> <span class="k">else</span> <span class="mi">300</span>
    <span class="k">else</span><span class="p">:</span>
    	<span class="n">lim</span> <span class="o">=</span> <span class="mi">15</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">==</span> <span class="s">"user"</span> <span class="k">else</span> <span class="mi">30</span>

    <span class="n">process_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">TIME</span>
    <span class="n">TIME</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
    <span class="n">cooldown</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="mi">15</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span> <span class="o">-</span> <span class="n">process_time</span>

    <span class="k">return</span> <span class="n">cooldown</span> <span class="k">if</span> <span class="n">cooldown</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
</code></pre></div><p>We can incorporate this into the existing functions as such:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_timeline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">twp</span><span class="o">.</span><span class="n">Cursor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">user_timeline</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cursor</span><span class="o">.</span><span class="n">pages</span><span class="p">():</span>
        <span class="n">sleep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sleepy_time</span><span class="p">(</span><span class="s">'timeline'</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">tweet</span> <span class="ow">in</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">tweet</span>
</code></pre></div><p>Using these functions between each iteration, the hope is to approximate $t(q)$ as defined before. To properly correct for computation time between functions, the method tries to see how much global time has passed since the previous call, however, if this is $-$, the current code does not smear that out across multiple iterations. This is something for future work.</p><h2 id="stream-and-geo">Stream and Geo</h2><p>Previously I talked about the possibility for one to interact with the Twitter stream. Here, you can ‘attach’ yourself to the entire live stream of messages that are sent over Twitter. Despite the fact that you can only see some very small percentage of the actual data, sometimes it’s useful to use in combination with a filter. The stream allows keyword filtering, as well as geo filtering. In the first case, we tell twitter that if there’s a certain keyword (for example ‘semantic’), we want it to show up in our stream. In Python, this would look something like this:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code>
<span class="mi">11</span><span class="p">:</span><span class="mi">49</span><span class="p">:</span><span class="mi">41</span> <span class="o">-</span> <span class="p">(</span><span class="n">stream</span><span class="p">):</span> <span class="n">filtering</span> <span class="n">keyword</span> <span class="s">'semantic'</span>
<span class="mi">11</span><span class="p">:</span><span class="mi">49</span><span class="p">:</span><span class="mi">42</span> <span class="o">-</span> <span class="p">(</span><span class="n">stream</span><span class="p">):</span> <span class="n">cravetrain</span><span class="p">:</span> <span class="n">Semantic</span> <span class="n">timeline</span> <span class="n">markup</span><span class="p">,</span> <span class="n">hCal</span> <span class="o">...</span>
<span class="mi">11</span><span class="p">:</span><span class="mi">54</span><span class="p">:</span><span class="mo">07</span> <span class="o">-</span> <span class="p">(</span><span class="n">stream</span><span class="p">):</span> <span class="n">djplb</span><span class="p">:</span> <span class="nd">@rustuswayne</span> <span class="n">Obama</span><span class="err">!</span><span class="n">s</span> <span class="n">Groundbreaking</span> <span class="o">...</span>

</code></pre></div><p>In order to pick these Tweets from the stream, we need to add a bit more code. First off, there needs to be a <code class="highlighter-rouge">StdOutListener</code> so that whatever is given to the streamer can actually be handled in Python:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">StdOutListener</span><span class="p">(</span><span class="n">twp</span><span class="o">.</span><span class="n">StreamListener</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">on_status</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">status</span><span class="p">[</span><span class="s">'text'</span><span class="p">])</span>
        <span class="c"># do some stuff with the status</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">on_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status_code</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>  <span class="c"># To continue listening</span>

    <span class="k">def</span> <span class="nf">on_timeout</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">True</span>  <span class="c"># To continue listening</span>

</code></pre></div><p>Replacing <code class="highlighter-rouge"># do some stuff...</code> with database or file interactions allows direct storing of any <a href="https://dev.twitter.com/rest/reference/post/statuses/update">Status Object</a> that the stream yields. To check if we’re doing fine, I wrote a small print for <code class="highlighter-rouge">status['text']</code> here. Now that we have this, we can go about writing the method to call the stream. We add this to the <code class="highlighter-rouge">TwAPI</code> class:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">o_filter</span><span class="p">):</span>
    <span class="n">listener</span> <span class="o">=</span> <span class="n">StdOutListener</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">twp</span><span class="o">.</span><span class="n">Stream</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">auth</span><span class="p">,</span> <span class="n">listener</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">o_filter</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">locations</span><span class="o">=</span><span class="n">o_filter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="nb">filter</span><span class="p">(</span><span class="n">o_filter</span><span class="p">)</span>
    <span class="k">except</span> <span class="nb">Exception</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">())</span>
</code></pre></div><p>As can be seen, we can give this method some filter; either a <code class="highlighter-rouge">str</code> or a <code class="highlighter-rouge">list</code>. The list functions as a bound box for coordinates, such as bb = [2.52490234375, 50.6976074219, 5.89248046875, 51.4911132813] (for Belgium). This will allow you to only collect tweets in some area. Alternatively, passing a string results in the keyword filter I discussed. Sadly, due to the fact that stream only allows you to view a small percentage of the actual data, the more specific your searches will be, the less frequent things will show up in the stream.</p><h2 id="twitter-datasets--list-of-ids">Twitter datasets &amp; List of IDs</h2><p>Luckily, we can avoid working with most of the heavy rate limits by using Twitter datasets. These datasets are usually constructed for research purposes; therefore, if you’re in luck they will have some form of annotation that provides more meta-data on instance. For example, one might receive a list of user IDs and an annotated gender. Close to every Twitter dataset offers either these user or tweet IDs that have to be resolved, as giving the entire status object is in violation of Twitter’s terms of service. It is therefore likely that one has to retrieve either the User or Status objects at some point. Twitter allows for feeding lists of 100 of such IDs, which we can use in code as such:</p><div class="language-python highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msl</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">api</span><span class="o">.</span><span class="n">statuses_lookup</span><span class="p">(</span><span class="n">msl</span><span class="p">,</span> <span class="n">include_entities</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="o">...</span>
<span class="k">for</span> <span class="mi">100</span><span class="n">_batch</span> <span class="ow">in</span> <span class="n">batchlist</span><span class="p">:</span>
	<span class="n">sleep</span><span class="p">(</span><span class="n">api</span><span class="o">.</span><span class="n">sleepy_time</span><span class="p">(</span><span class="s">'messages'</span><span class="p">))</span>
	<span class="n">msgl</span> <span class="o">=</span> <span class="n">api</span><span class="o">.</span><span class="n">get_messages</span><span class="p">(</span><span class="mi">100</span><span class="n">_batch</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">msgl</span><span class="p">:</span>
		<span class="c"># do something</span>
</code></pre></div><p>This would start resolving the ID’s, after which they can be written do a database, file, or whatever. The advantage here is that at times you are able to process tweets much faster; say that we have 100.000 messages, then $t(q) = 100.000 / 100 \cdot 15\cdot60 / 180 = 5000$ seconds. In comparison with for example the user timeline where we would need to retrieve around 30 profiles for the same amount of messages, then $t(q) = 100.000 / 200 \cdot 15 \cdot 60 / 300 = 1500$ seconds only, this is slower. However, seeing that we already know what we are looking for (each tweet is relevant to our research), and that we still process 20 tweets per second, this is a good trade-off to make in specific cases.</p></article><div class="back"> <a href="/"></a></div></main></body></html>